# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @export
RGBtoHSL <- function(im) {
    .Call('imager_RGBtoHSL', PACKAGE = 'imager', im)
}

#' @export
HSLtoRGB <- function(im) {
    .Call('imager_HSLtoRGB', PACKAGE = 'imager', im)
}

#' @export
RGBtoHSV <- function(im) {
    .Call('imager_RGBtoHSV', PACKAGE = 'imager', im)
}

#' @export
HSVtoRGB <- function(im) {
    .Call('imager_HSVtoRGB', PACKAGE = 'imager', im)
}

#' @export
RGBtoHSI <- function(im) {
    .Call('imager_RGBtoHSI', PACKAGE = 'imager', im)
}

#' @export
HSItoRGB <- function(im) {
    .Call('imager_HSItoRGB', PACKAGE = 'imager', im)
}

#' @export
RGBtosRGB <- function(im) {
    .Call('imager_RGBtosRGB', PACKAGE = 'imager', im)
}

#' @export
sRGBtoRGB <- function(im) {
    .Call('imager_sRGBtoRGB', PACKAGE = 'imager', im)
}

#' @export
RGBtoYCbCr <- function(im) {
    .Call('imager_RGBtoYCbCr', PACKAGE = 'imager', im)
}

#' @export
YCbCrtoRGB <- function(im) {
    .Call('imager_YCbCrtoRGB', PACKAGE = 'imager', im)
}

#' @export
RGBtoYUV <- function(im) {
    .Call('imager_RGBtoYUV', PACKAGE = 'imager', im)
}

#' @export
YUVtoRGB <- function(im) {
    .Call('imager_YUVtoRGB', PACKAGE = 'imager', im)
}

#' Convert an RGB image to grayscale 
#' 
#' This function converts from RGB to grayscale by first converting to HSL and keeping only the L channel
#' @return a grayscale image (spectrum == 1)
#' @export
grayscale <- function(im) {
    .Call('imager_grayscale', PACKAGE = 'imager', im)
}

#' Display image using CImg library
#'
#' @param im an image (cimg object)
#' @export
display <- function(im) {
    invisible(.Call('imager_display', PACKAGE = 'imager', im))
}

#' Display image list using CImg library
#'
#' @param imlist a list of cimg objects
#' @export
display_list <- function(imlist) {
    invisible(.Call('imager_display_list', PACKAGE = 'imager', imlist))
}

#' Play a video 
#'
#' A very basic video player. Press the space bar to pause and ESC to close. 
#' @param vid A cimg object, to be played as video
#' @param loop loop the video (default false)
#' @param delay delay between frames, in ms. Default 30. 
#' @export
play <- function(vid, loop = FALSE, delay = 30L) {
    invisible(.Call('imager_play', PACKAGE = 'imager', vid, loop, delay))
}

#' Bucket fill
#' @param x X-coordinate of the starting point of the region to fill.
#' @param y Y-coordinate of the starting point of the region to fill.
#' @param z Z-coordinate of the starting point of the region to fill.
#' @param color Pointer to spectrum() consecutive values, defining the drawing color.
#' @param sigma Tolerance concerning neighborhood values.
#' @param opacity Opacity of the drawing.
#' @param is_high_connexity Use 8-connexity (only for 2d images).
#' @export
bucket_fill <- function(im, x, y, z, color, opacity = 1, sigma = 0, is_high_connexity = FALSE) {
    .Call('imager_bucket_fill', PACKAGE = 'imager', im, x, y, z, color, opacity, sigma, is_high_connexity)
}

#' Select a region of homogeneous colour 
#'
#' The underlying algorithm is the same as the bucket fill (AKA flood fill). Unlike with the bucket fill, the image isn't changed, the function simply returns a binary mask of the selected region
#'
#' @param x X-coordinate of the starting point of the region to fill.
#' @param y Y-coordinate of the starting point of the region to fill.
#' @param z Z-coordinate of the starting point of the region to fill.
#' @param sigma Tolerance concerning neighborhood values.
#' @param is_high_connexity Use 8-connexity (only for 2d images).
#' @export
bucket_select <- function(im, x, y, z, sigma = 0, is_high_connexity = FALSE) {
    .Call('imager_bucket_select', PACKAGE = 'imager', im, x, y, z, sigma, is_high_connexity)
}

#' Apply recursive Deriche filter.
#'
#' @param im an image
#' @param sigma Standard deviation of the filter.
#' @param order Order of the filter. Can be <tt>{ 0=smooth-filter | 1=1st-derivative | 2=2nd-derivative }</tt>.
#' @param axis Axis along which the filter is computed. Can be <tt>{ 'x' | 'y' | 'z' | 'c' }</tt>.
#' @param boundary_conditions Boundary conditions. Can be <tt>{ 0=dirichlet | 1=neumann }</tt>.
#' @export
deriche <- function(im, sigma, order = 0L, axis = 'x', boundary_conditions = 0L) {
    .Call('imager_deriche', PACKAGE = 'imager', im, sigma, order, axis, boundary_conditions)
}

#' Van Vliet recursive Gaussian filter.
#'
#'       From: I.T. Young, L.J. van Vliet, M. van Ginkel, Recursive Gabor filtering.
#'       IEEE Trans. Sig. Proc., vol. 50, pp. 2799-2805, 2002.
#'       (this is an improvement over Young-Van Vliet, Sig. Proc. 44, 1995)
#'
#'       Boundary conditions (only for order 0) using Triggs matrix, from
#'       B. Triggs and M. Sdika. Boundary conditions for Young-van Vliet
#'       recursive filtering. IEEE Trans. Signal Processing,
#'       vol. 54, pp. 2365-2367, 2006.
#'
#'       @param im an image
#'       @param sigma standard deviation of the Gaussian filter
#'       @param order the order of the filter 0,1,2,3
#'       @param axis  Axis along which the filter is computed. Can be <tt>{ 'x' | 'y' | 'z' | 'c' }</tt>.
#'       @param boundary_conditions Boundary conditions. Can be <tt>{ 0=dirichlet | 1=neumann }</tt>.
#'       (Dirichlet boundary condition has a strange behavior)
#' @export
vanvliet <- function(im, sigma, order = 0L, axis = 'x', boundary_conditions = 0L) {
    .Call('imager_vanvliet', PACKAGE = 'imager', im, sigma, order, axis, boundary_conditions)
}

#' Blur image isotropically.
#' @param im an image
#' @param sigma Standard deviation of the blur.
#' @param boundary_conditions Boundary conditions. Can be <tt>{ 0=dirichlet | 1=neumann }
#' @seealso
#'  deriche(), vanvliet().
#' @export
isoblur <- function(im, sigma, boundary_conditions = TRUE, is_gaussian = FALSE) {
    .Call('imager_isoblur', PACKAGE = 'imager', im, sigma, boundary_conditions, is_gaussian)
}

#' Blur image with the median filter.
#'    
#' @param im an image
#'  @param n Size of the median filter.
#'  @param threshold Threshold used to discard pixels too far from the current pixel value in the median computation.
#' @export
medianblur <- function(im, n, threshold) {
    .Call('imager_medianblur', PACKAGE = 'imager', im, n, threshold)
}

#' Blur image with a box filter.
#' @param im an image
#' @param sigma Size of the box window.
#' @param boundary_conditions Boundary conditions. Can be <tt>{ 0=dirichlet | 1=neumann }</tt>.a
#' @seealso deriche(), vanvliet().
#' @export
boxblur <- function(im, sigma, boundary_conditions = TRUE) {
    .Call('imager_boxblur', PACKAGE = 'imager', im, sigma, boundary_conditions)
}

#' Blur image with a box filter.
#'
#' This is a recursive algorithm, not depending on the values of the box kernel size.
#'
#'       @param im an image
#'       @param sigma_x Size of the box window, along the X-axis.
#'       @param sigma_y Size of the box window, along the Y-axis.
#'       @param boundary_conditions Boundary conditions. Can be <tt>{ false=dirichlet | true=neumann }</tt>.
#'       @seealso blur().
#'
#' @export
boxblur_xy <- function(im, sx, sy, boundary_conditions = TRUE) {
    .Call('imager_boxblur_xy', PACKAGE = 'imager', im, sx, sy, boundary_conditions)
}

#' Correlate image by a mask.
#'
#'  The correlation of the image instance this by the mask mask is defined to be:
#'  res(x,y,z) = sum_{i,j,k} (*this)(x + i,y + j,z + k)*mask(i,j,k).
#'
#'       @param im an image
#'       @param mask = the correlation kernel.
#'       @param boundary_conditions = the border condition type (0=zero, 1=dirichlet)
#'       @param is_normalized = enable local normalization.
#'      
#'
#' @export
correlate <- function(im, filter, boundary_conditions = TRUE, is_normalised = FALSE) {
    .Call('imager_correlate', PACKAGE = 'imager', im, filter, boundary_conditions, is_normalised)
}

#' Convolve image by a mask.
#'
#'      The result  res of the convolution of an image img by a mask mask is defined to be:
#'       res(x,y,z) = sum_{i,j,k} img(x-i,y-j,z-k)*mask(i,j,k)
#'
#'       @param im an image
#'       @param mask = the convolution kernel.
#'       @param boundary_conditions = the border condition type (0=zero, 1=dirichlet)
#'       @param is_normalized = enable local normalization.
#'
#'
#' @export
convolve <- function(im, filter, boundary_conditions = TRUE, is_normalised = FALSE) {
    .Call('imager_convolve', PACKAGE = 'imager', im, filter, boundary_conditions, is_normalised)
}

#' Sharpen image.
#'
#'       @param im an image
#'       @param amplitude Sharpening amplitude
#'       @param sharpen_type Select sharpening method. Can be <tt>{ false=inverse diffusion | true=shock filters }</tt>.
#'       @param edge Edge threshold (shock filters only).
#'       @param alpha Gradient smoothness (shock filters only).
#'       @param sigma Tensor smoothness (shock filters only).
#'
#' @export
imsharpen <- function(im, amplitude, sharpen_type = FALSE, edge = 1, alpha = 0, sigma = 0) {
    .Call('imager_imsharpen', PACKAGE = 'imager', im, amplitude, sharpen_type, edge, alpha, sigma)
}

#' Compute image gradient.
#'
#' @param im an image
#' @param axes Axes considered for the gradient computation, as a C-string (e.g "xy").
#' @param scheme = Numerical scheme used for the gradient computation:
#'       1 = Backward finite differences
#'       0 = Centered finite differences
#'       1 = Forward finite differences
#'       2 = Using Sobel masks
#'       3 = Using rotation invariant masks
#'       4 = Using Deriche recursive filter.
#'       5 = Using Van Vliet recursive filter.
#' @return a list of images (corresponding to the different directions)
#' @export
get_gradient <- function(im, axes = "", scheme = 3L) {
    .Call('imager_get_gradient', PACKAGE = 'imager', im, axes, scheme)
}

#' Return image hessian.
#' @param im an image
#' @param axes Axes considered for the hessian computation, as a character string (e.g "xy").
#' @export
get_hessian <- function(im, axes = "") {
    .Call('imager_get_hessian', PACKAGE = 'imager', im, axes)
}

#' Compute field of diffusion tensors for edge-preserving smoothing.
#'
#'       @param im an image
#'       @param sharpness Sharpness
#'       @param anisotropy Anisotropy
#'       @param alpha Standard deviation of the gradient blur.
#'       @param sigma Standard deviation of the structure tensor blur.
#'       @param is_sqrt Tells if the square root of the tensor field is computed instead.
#' @export
diffusion_tensors <- function(im, sharpness = 0.7, anisotropy = 0.6, alpha = 0.6, sigma = 1.1, is_sqrt = FALSE) {
    .Call('imager_diffusion_tensors', PACKAGE = 'imager', im, sharpness, anisotropy, alpha, sigma, is_sqrt)
}

#' Compute Haar multiscale wavelet transform.
#'
#'       @param im an image
#'       @param axis Axis considered for the transform.
#'       @param invert Set inverse of direct transform.
#'       @param nb_scales Number of scales used for the transform.
#'
#' @export
haar <- function(im, inverse = FALSE, nb_scales = 1L) {
    .Call('imager_haar', PACKAGE = 'imager', im, inverse, nb_scales)
}

FFT_complex <- function(real, imag, inverse = FALSE, nb_threads = 0L) {
    .Call('imager_FFT_complex', PACKAGE = 'imager', real, imag, inverse, nb_threads)
}

FFT_realim <- function(real, inverse = FALSE, nb_threads = 0L) {
    .Call('imager_FFT_realim', PACKAGE = 'imager', real, inverse, nb_threads)
}

FFT_realout <- function(real, imag, inverse = FALSE, nb_threads = 0L) {
    .Call('imager_FFT_realout', PACKAGE = 'imager', real, imag, inverse, nb_threads)
}

#' Estimate displacement field between two images.
#'
#' @param source Reference image.
#' @param smoothness Smoothness of estimated displacement field.
#' @param precision Precision required for algorithm convergence.
#' @param nb_scales Number of scales used to estimate the displacement field.
#' @param iteration_max Maximum number of iterations allowed for one scale.
#' @param is_backward If false, match I2(X + U(X)) = I1(X), else match I2(X) = I1(X - U(X)).
#' @export
displacement <- function(sourceIm, destIm, smoothness = 0.1, precision = 5.0, nb_scales = 0L, iteration_max = 10000L, is_backward = FALSE) {
    .Call('imager_displacement', PACKAGE = 'imager', sourceIm, destIm, smoothness, precision, nb_scales, iteration_max, is_backward)
}

#' Blur image anisotropically, in an edge-preserving way.
#' @param amplitude Amplitude of the smoothing.
#' @param sharpness Sharpness.
#' @param anisotropy Anisotropy.
#' @param alpha Standard deviation of the gradient blur.
#' @param sigma Standard deviation of the structure tensor blur.
#' @param dl Spatial discretization.
#' @param da Angular discretization.
#' @param gauss_prec Precision of the diffusion process.
#' @param interpolation_type Interpolation scheme.
#'  Can be 0=nearest-neighbor | 1=linear | 2=Runge-Kutta 
#' @param is_fast_approx Determines if a fast approximation of the gaussian function is used or not.
#' @export
#' @examples
#' im <- load.image(system.file('extdata/Leonardo_Birds.jpg',package='imager'))
#' im.noisy <- (im + 80*rnorm(prod(dim(im)))) 
#' blur_anisotropic(im.noisy,ampl=1e4,sharp=1) %>% plot
blur_anisotropic <- function(im, amplitude, sharpness = 0.7, anisotropy = 0.6, alpha = 0.6, sigma = 1.1, dl = 0.8, da = 30, gauss_prec = 2, interpolation_type = 0L, is_fast_approx = TRUE) {
    .Call('imager_blur_anisotropic', PACKAGE = 'imager', im, amplitude, sharpness, anisotropy, alpha, sigma, dl, da, gauss_prec, interpolation_type, is_fast_approx)
}

periodic_part <- function(im) {
    .Call('imager_periodic_part', PACKAGE = 'imager', im)
}

#' @export
interp_xy <- function(inp, ix, iy, z = 0L, c = 0L, cubic = FALSE) {
    .Call('imager_interp_xy', PACKAGE = 'imager', inp, ix, iy, z, c, cubic)
}

#' @export
interp_xyz <- function(inp, ix, iy, iz, c = 0L, cubic = FALSE) {
    .Call('imager_interp_xyz', PACKAGE = 'imager', inp, ix, iy, iz, c, cubic)
}

#' @export
interp_xyzc <- function(inp, ix, iy, iz, ic, cubic = FALSE) {
    .Call('imager_interp_xyzc', PACKAGE = 'imager', inp, ix, iy, iz, ic, cubic)
}

#' @export
interp_xyc <- function(inp, ix, iy, z, ic, cubic = FALSE) {
    .Call('imager_interp_xyc', PACKAGE = 'imager', inp, ix, iy, z, ic, cubic)
}

#' Label connected components.
#'
#' The algorithm of connected components computation has been primarily done
#'by A. Meijster, according to the publication:
#''W.H. Hesselink, A. Meijster, C. Bron, "Concurrent Determination of Connected Components.",
#'       In: Science of Computer Programming 41 (2001), pp. 173--194'.
#'
#' @param is_high_connectivity Boolean that choose between 4(false)- or 8(true)-connectivity
#'       in 2d case, and between 6(false)- or 26(true)-connectivity in 3d case.
#' @param tolerance Tolerance used to determine if two neighboring pixels belong to the same region.
#' @export
label <- function(im, is_high_connectivity = FALSE, tolerance = 0) {
    .Call('imager_label', PACKAGE = 'imager', im, is_high_connectivity, tolerance)
}

#' Erode image by a structuring element.
#'
#' @param mask Structuring element.
#'       @param boundary_conditions Boundary conditions.
#'       @param is_normalized Sets if the erosion is locally normalized.
#'
#' @export
erode <- function(im, mask, boundary_conditions = TRUE, is_normalised = FALSE) {
    .Call('imager_erode', PACKAGE = 'imager', im, mask, boundary_conditions, is_normalised)
}

#' Erode image by a rectangular structuring element of specified size.
#'       @param sx Width of the structuring element.
#'       @param sy Height of the structuring element.
#'       @param sz Depth of the structuring element.
#'
#'
#' @export
erode_rect <- function(im, sx, sy, sz = 1L) {
    .Call('imager_erode_rect', PACKAGE = 'imager', im, sx, sy, sz)
}

#' Erode image by a  square structuring element of specified size.
#'       @param size size of the structuring element.
#'
#' @export
erode_square <- function(im, size) {
    .Call('imager_erode_square', PACKAGE = 'imager', im, size)
}

#' Dilate image by a structuring element.
#'      @param mask Structuring element.
#'       @param boundary_conditions Boundary conditions.
#'       @param is_normalized Sets if the erosion is locally normalized.
#' @export
dilate <- function(im, mask, boundary_conditions = TRUE, is_normalised = FALSE) {
    .Call('imager_dilate', PACKAGE = 'imager', im, mask, boundary_conditions, is_normalised)
}

#' Dilate image by a rectangular structuring element of specified size.
#'
#'       @param sx Width of the structuring element.
#'       @param sy Height of the structuring element.
#'       @param sz Depth of the structuring element.
#' @export
dilate_rect <- function(im, sx, sy, sz = 1L) {
    .Call('imager_dilate_rect', PACKAGE = 'imager', im, sx, sy, sz)
}

#' Dilate image by a square structuring element of specified size.
#'
#'       @param size Size of the structuring element.
#' @export
dilate_square <- function(im, size) {
    .Call('imager_dilate_square', PACKAGE = 'imager', im, size)
}

#' Compute watershed transform.
#'
#'       Non-zero values are propagated to zero-valued ones according to
#'       the priority map.
#'       @param priority Priority map.
#'       @param fill_lines Sets if watershed lines must be filled or not.
#'
#' @export
watershed <- function(im, priority, fill_lines = TRUE) {
    .Call('imager_watershed', PACKAGE = 'imager', im, priority, fill_lines)
}

#' Compute Euclidean distance function to a specified value.
#'
#'        The distance transform implementation has been submitted by A. Meijster, and implements
#'        the article 'W.H. Hesselink, A. Meijster, J.B.T.M. Roerdink,
#'                     "A general algorithm for computing distance transforms in linear time.",
#'                     In: Mathematical Morphology and its Applications to Image and Signal Processing,
#'                     J. Goutsias, L. Vincent, and D.S. Bloomberg (eds.), Kluwer, 2000, pp. 331-340.'
#'         The submitted code has then been modified to fit CImg coding style and constraints.
#' @param value Reference value.
#' @param metric Type of metric. Can be <tt>{ 0=Chebyshev | 1=Manhattan | 2=Euclidean | 3=Squared-euclidean }</tt>.
#' @export
distance_transform <- function(im, value, metric = 2L) {
    .Call('imager_distance_transform', PACKAGE = 'imager', im, value, metric)
}

#' Morphological opening (erosion followed by dilation)
#'
#' @param mask Structuring element.
#' @param boundary_conditions Boundary conditions.
#' @param is_normalized Determines if the opening is locally normalized.
#'
#' @export
mopening <- function(im, mask, boundary_conditions = TRUE, is_normalised = FALSE) {
    .Call('imager_mopening', PACKAGE = 'imager', im, mask, boundary_conditions, is_normalised)
}

#' Morphological opening by a square element (erosion followed by dilation)
#'
#' @param size size of the square element
#'
#' @export
mopening_square <- function(im, size) {
    .Call('imager_mopening_square', PACKAGE = 'imager', im, size)
}

#' Morphological closing by a square element (dilation followed by erosion)
#'
#' @param size size of the square element
#'
#' @export
mclosing_square <- function(im, size) {
    .Call('imager_mclosing_square', PACKAGE = 'imager', im, size)
}

#' Morphological closing (dilation followed by erosion)
#'
#' @param mask Structuring element.
#' @param boundary_conditions Boundary conditions.
#' @param is_normalized Determines if the closing is locally normalized.
#'
#' @export
mclosing <- function(im, mask, boundary_conditions = TRUE, is_normalised = FALSE) {
    .Call('imager_mclosing', PACKAGE = 'imager', im, mask, boundary_conditions, is_normalised)
}

#' Autocrop image region 
#'
#' @param color Color used for the crop. If  0, color is guessed.
#' @param axes Axes used for the crop.
#' @export
autocrop <- function(im, color, axes = "zyx") {
    .Call('imager_autocrop', PACKAGE = 'imager', im, color, axes)
}

#' Rotate image by an arbitrary angle.
#'
#' Most of the time, the size of the image is modified.
#'
#' @param angle Rotation angle, in degrees.
#' @param interpolation Type of interpolation. Can be <tt>{ 0=nearest | 1=linear | 2=cubic }</tt>.
#' @param boundary Boundary conditions. Can be <tt>{  0=dirichlet | 1=neumann | 2=periodic }</tt>.
#' @export
imrotate <- function(im, angle, interpolation = 1L, boundary = 0L) {
    .Call('imager_imrotate', PACKAGE = 'imager', im, angle, interpolation, boundary)
}

#' Rotate image by an arbitrary angle, around a center point.
#'
#'       @param angle Rotation angle, in degrees.
#'       @param cx X-coordinate of the rotation center.
#'       @param cy Y-coordinate of the rotation center.
#'       @param zoom Zoom factor.
#'       @param boundary_conditions Boundary conditions. Can be <tt>{ 0=dirichlet | 1=neumann | 2=periodic }</tt>.
#'       @param interpolation_type Type of interpolation. Can be <tt>{ 0=nearest | 1=linear | 2=cubic }</tt>.
#'
#' @export
rotate_xy <- function(im, angle, cx, cy, zoom = 1, interpolation = 1L, boundary = 0L) {
    .Call('imager_rotate_xy', PACKAGE = 'imager', im, angle, cx, cy, zoom, interpolation, boundary)
}

#' Mirror image content along specified axis 
#'       @param axis Mirror axis ("x","y","z","c")
#' @export
mirror <- function(im, axis) {
    .Call('imager_mirror', PACKAGE = 'imager', im, axis)
}

#' @export
permute_axes <- function(im, perm) {
    .Call('imager_permute_axes', PACKAGE = 'imager', im, perm)
}

#' Resize image to double-size, using the Scale2X algorithm.
#'
#'Use anisotropic upscaling algorithm
#'       <a href="http://scale2x.sourceforge.net/algorithm.html">described here</a>.
#' @export
resize_doubleXY <- function(im) {
    .Call('imager_resize_doubleXY', PACKAGE = 'imager', im)
}

#' Resize image to half-size, using an optimized filter
#'
#'Use anisotropic upscaling algorithm
#'       <a href="http://scale2x.sourceforge.net/algorithm.html">described here</a>.
#' @export
resize_halfXY <- function(im) {
    .Call('imager_resize_halfXY', PACKAGE = 'imager', im)
}

#' Resize image to triple-size, using the Scale2X algorithm.
#'
#'Use anisotropic upscaling algorithm
#'       <a href="http://scale2x.sourceforge.net/algorithm.html">described here</a>.
#' @export
resize_tripleXY <- function(im) {
    .Call('imager_resize_tripleXY', PACKAGE = 'imager', im)
}

#' Shift image content.
#'
#'       @param delta_x Amount of displacement along the X-axis.
#'       @param delta_y Amount of displacement along the Y-axis.
#'       @param delta_z Amount of displacement along the Z-axis.
#'       @param delta_c Amount of displacement along the C-axis.
#'       @param boundary_conditions can be:
#'          - 0: Zero border condition (Dirichlet).
#'          - 1: Nearest neighbors (Neumann).
#'          - 2: Repeat Pattern (Fourier style).
#' @export
imshift <- function(im, delta_x = 0L, delta_y = 0L, delta_z = 0L, delta_c = 0L, boundary_conditions = 0L) {
    .Call('imager_imshift', PACKAGE = 'imager', im, delta_x, delta_y, delta_z, delta_c, boundary_conditions)
}

#' Resize image to new dimensions.
#' If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).
#' @param size_x Number of columns (new size along the X-axis).
#' @param size_y Number of rows (new size along the Y-axis).
#' @param size_z Number of slices (new size along the Z-axis).
#' @param size_c Number of vector-channels (new size along the C-axis).
#' @param interpolation_type Method of interpolation:
#' -1 = no interpolation: raw memory resizing.
#' 0 = no interpolation: additional space is filled according to  boundary_conditions.
#' 1 = nearest-neighbor interpolation.
#' 2 = moving average interpolation.
#' 3 = linear interpolation.
#' 4 = grid interpolation.
#' 5 = cubic interpolation.
#' 6 = lanczos interpolation.
#' @param boundary_conditions Border condition type.
#' @param centering_x Set centering type (only if  interpolation_type=0).
#' @param centering_y Set centering type (only if  interpolation_type=0).
#' @param centering_z Set centering type (only if  interpolation_type=0).
#' @param centering_c Set centering type (only if  interpolation_type=0).
#' @export
resize <- function(im, size_x = -100L, size_y = -100L, size_z = -100L, size_c = -100L, interpolation_type = 1L, boundary_conditions = 0L, centering_x = 0, centering_y = 0, centering_z = 0, centering_c = 0) {
    .Call('imager_resize', PACKAGE = 'imager', im, size_x, size_y, size_z, size_c, interpolation_type, boundary_conditions, centering_x, centering_y, centering_z, centering_c)
}

#' Warp image
#'
#' @param warp Warping field. The (x,y,z) fields should be stacked along the colour coordinate. 
#' @param mode Can be { 0=backward-absolute | 1=backward-relative | 2=forward-absolute | 3=forward-relative }
#' @param is_relative does warping field give absolute or relative warping coordinates?
#' @param interpolation Can be <tt>{ 0=nearest | 1=linear | 2=cubic }</tt>.
#' @param boundary_conditions Boundary conditions. Can be <tt>{ 0=dirichlet | 1=neumann | 2=periodic }</tt>.
#' @seealso imwarp for a user-friendly interface
#' @export
warp <- function(im, warpfield, mode = 0L, interpolation = 1L, boundary_conditions = 0L) {
    .Call('imager_warp', PACKAGE = 'imager', im, warpfield, mode, interpolation, boundary_conditions)
}

#' @export
load_image <- function(fname) {
    .Call('imager_load_image', PACKAGE = 'imager', fname)
}

#' @export
save_image <- function(im, fname) {
    invisible(.Call('imager_save_image', PACKAGE = 'imager', im, fname))
}

#' Split an image along a certain axis (producing a list)
#' 
#' @param im an image 
#' @param axis the axis along which to split (for example 'c')
#' @param nb number of objects to split into. 
#' if nb=-1 (the default) the maximum number of splits is used ie. split(im,"c") produces a list containing all individual colour channels
#' @seealso imappend (the reverse operation)
im_split <- function(im, axis, nb = -1L) {
    .Call('imager_im_split', PACKAGE = 'imager', im, axis, nb)
}

#' Combine a list of images into a single image 
#' 
#' All images will be concatenated along the x,y,z, or c axis.
#' 
#' @param im an image 
#' @param axis the axis along which to split (for example 'c')
#' @seealso imsplit (the reverse operation)
#' @export
imappend <- function(imlist, axis) {
    .Call('imager_imappend', PACKAGE = 'imager', imlist, axis)
}

#' Return image patches centered at cx,cy with width wx and height wy
#'
#' @param cx,cy: vector of coordinates for patch centers
#' @param wx,wy: vector of coordinates for patch width and height
#' @export
select_patches <- function(im, cx, cy, wx, wy) {
    .Call('imager_select_patches', PACKAGE = 'imager', im, cx, cy, wx, wy)
}

#' @export
select_patches3D <- function(im, cx, cy, cz, wx, wy, wz) {
    .Call('imager_select_patches3D', PACKAGE = 'imager', im, cx, cy, cz, wx, wy, wz)
}

# Register entry points for exported C++ functions
methods::setLoadAction(function(ns) {
    .Call('imager_RcppExport_registerCCallable', PACKAGE = 'imager')
})
